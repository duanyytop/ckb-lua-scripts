//
// If you have only one single C file, you can include std header files in it,
// and then done. It automatically includes impl.c(this file). It is compatible
// to a lot of old CKB code.
//
// If you have more than one C file, and it's a big project. You need to define
// macro CKB_DECLARATION_ONLY for every C files. Compile very C file, together
// with this impl.c (compiled *without* macro CKB_DECLARATION_ONLY) and then
// link them together.
//

#ifndef __CKB_IMPL_INCLUDED__
#define __CKB_IMPL_INCLUDED__

#include <internal/atomic.h>
#include <internal/types.h>
#include <limits.h>
#include <locale.h>
#include <math.h>
#include <setjmp.h>
#include <stdarg.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>

/*
 * The implementation here is based on musl-libc with modifications for our
 * use case. The original musl-libc follows MIT license, thanks to the authors
 * for the creation.
 */

void *memset(void *dest, int c, size_t n) {
  unsigned char *s = dest;
#ifndef __OPTIMIZE_SIZE__
  size_t k;

  /* Fill head and tail with minimal branching. Each
   * conditional ensures that all the subsequently used
   * offsets are well-defined and in the dest region. */

  if (!n)
    return dest;
  s[0] = c;
  s[n - 1] = c;
  if (n <= 2)
    return dest;
  s[1] = c;
  s[2] = c;
  s[n - 2] = c;
  s[n - 3] = c;
  if (n <= 6)
    return dest;
  s[3] = c;
  s[n - 4] = c;
  if (n <= 8)
    return dest;

  /* Advance pointer to align it at a 4-byte boundary,
   * and truncate n to a multiple of 4. The previous code
   * already took care of any head/tail that get cut off
   * by the alignment. */

  k = -(uintptr_t)s & 3;
  s += k;
  n -= k;
  n &= -4;

#ifdef __GNUC__
  typedef uint32_t __attribute__((__may_alias__)) u32;
  typedef uint64_t __attribute__((__may_alias__)) u64;

  u32 c32 = ((u32)-1) / 255 * (unsigned char)c;

  /* In preparation to copy 32 bytes at a time, aligned on
   * an 8-byte bounary, fill head/tail up to 28 bytes each.
   * As in the initial byte-based head/tail fill, each
   * conditional below ensures that the subsequent offsets
   * are valid (e.g. !(n<=24) implies n>=28). */

  *(u32 *)(s + 0) = c32;
  *(u32 *)(s + n - 4) = c32;
  if (n <= 8)
    return dest;
  *(u32 *)(s + 4) = c32;
  *(u32 *)(s + 8) = c32;
  *(u32 *)(s + n - 12) = c32;
  *(u32 *)(s + n - 8) = c32;
  if (n <= 24)
    return dest;
  *(u32 *)(s + 12) = c32;
  *(u32 *)(s + 16) = c32;
  *(u32 *)(s + 20) = c32;
  *(u32 *)(s + 24) = c32;
  *(u32 *)(s + n - 28) = c32;
  *(u32 *)(s + n - 24) = c32;
  *(u32 *)(s + n - 20) = c32;
  *(u32 *)(s + n - 16) = c32;

  /* Align to a multiple of 8 so we can fill 64 bits at a time,
   * and avoid writing the same bytes twice as much as is
   * practical without introducing additional branching. */

  k = 24 + ((uintptr_t)s & 4);
  s += k;
  n -= k;

  /* If this loop is reached, 28 tail bytes have already been
   * filled, so any remainder when n drops below 32 can be
   * safely ignored. */

  u64 c64 = c32 | ((u64)c32 << 32);
  for (; n >= 32; n -= 32, s += 32) {
    *(u64 *)(s + 0) = c64;
    *(u64 *)(s + 8) = c64;
    *(u64 *)(s + 16) = c64;
    *(u64 *)(s + 24) = c64;
  }
#else
  /* Pure C fallback with no aliasing violations. */
  for (; n; n--, s++)
    *s = c;
#endif

#else
  for (; n; n--, s++)
    *s = c;
#endif /* __OPTIMIZE_SIZE__ */

  return dest;
}

void *memcpy(void *restrict dest, const void *restrict src, size_t n) {
  unsigned char *d = dest;
  const unsigned char *s = src;

#if defined(__GNUC__) && (!defined(__OPTIMIZE_SIZE__))

#if __BYTE_ORDER == __LITTLE_ENDIAN
#define LS >>
#define RS <<
#else
#define LS <<
#define RS >>
#endif

  typedef uint32_t __attribute__((__may_alias__)) u32;
  uint32_t w, x;

  for (; (uintptr_t)s % 4 && n; n--)
    *d++ = *s++;

  if ((uintptr_t)d % 4 == 0) {
    for (; n >= 16; s += 16, d += 16, n -= 16) {
      *(u32 *)(d + 0) = *(u32 *)(s + 0);
      *(u32 *)(d + 4) = *(u32 *)(s + 4);
      *(u32 *)(d + 8) = *(u32 *)(s + 8);
      *(u32 *)(d + 12) = *(u32 *)(s + 12);
    }
    if (n & 8) {
      *(u32 *)(d + 0) = *(u32 *)(s + 0);

      *(u32 *)(d + 4) = *(u32 *)(s + 4);
      d += 8;
      s += 8;
    }
    if (n & 4) {
      *(u32 *)(d + 0) = *(u32 *)(s + 0);
      d += 4;
      s += 4;
    }
    if (n & 2) {
      *d++ = *s++;
      *d++ = *s++;
    }
    if (n & 1) {
      *d = *s;
    }
    return dest;
  }

  if (n >= 32)
    switch ((uintptr_t)d % 4) {
    case 1:
      w = *(u32 *)s;
      *d++ = *s++;
      *d++ = *s++;
      *d++ = *s++;
      n -= 3;
      for (; n >= 17; s += 16, d += 16, n -= 16) {
        x = *(u32 *)(s + 1);
        *(u32 *)(d + 0) = (w LS 24) | (x RS 8);
        w = *(u32 *)(s + 5);
        *(u32 *)(d + 4) = (x LS 24) | (w RS 8);
        x = *(u32 *)(s + 9);
        *(u32 *)(d + 8) = (w LS 24) | (x RS 8);
        w = *(u32 *)(s + 13);
        *(u32 *)(d + 12) = (x LS 24) | (w RS 8);
      }
      break;
    case 2:
      w = *(u32 *)s;
      *d++ = *s++;
      *d++ = *s++;
      n -= 2;
      for (; n >= 18; s += 16, d += 16, n -= 16) {
        x = *(u32 *)(s + 2);
        *(u32 *)(d + 0) = (w LS 16) | (x RS 16);
        w = *(u32 *)(s + 6);
        *(u32 *)(d + 4) = (x LS 16) | (w RS 16);
        x = *(u32 *)(s + 10);
        *(u32 *)(d + 8) = (w LS 16) | (x RS 16);
        w = *(u32 *)(s + 14);
        *(u32 *)(d + 12) = (x LS 16) | (w RS 16);
      }
      break;
    case 3:
      w = *(u32 *)s;
      *d++ = *s++;
      n -= 1;
      for (; n >= 19; s += 16, d += 16, n -= 16) {
        x = *(u32 *)(s + 3);
        *(u32 *)(d + 0) = (w LS 8) | (x RS 24);
        w = *(u32 *)(s + 7);
        *(u32 *)(d + 4) = (x LS 8) | (w RS 24);
        x = *(u32 *)(s + 11);
        *(u32 *)(d + 8) = (w LS 8) | (x RS 24);
        w = *(u32 *)(s + 15);
        *(u32 *)(d + 12) = (x LS 8) | (w RS 24);
      }
      break;
    }
  if (n & 16) {
    *d++ = *s++;
    *d++ = *s++;
    *d++ = *s++;
    *d++ = *s++;
    *d++ = *s++;
    *d++ = *s++;
    *d++ = *s++;
    *d++ = *s++;
    *d++ = *s++;
    *d++ = *s++;
    *d++ = *s++;
    *d++ = *s++;
    *d++ = *s++;
    *d++ = *s++;
    *d++ = *s++;
    *d++ = *s++;
  }
  if (n & 8) {
    *d++ = *s++;
    *d++ = *s++;
    *d++ = *s++;
    *d++ = *s++;
    *d++ = *s++;
    *d++ = *s++;
    *d++ = *s++;
    *d++ = *s++;
  }
  if (n & 4) {
    *d++ = *s++;
    *d++ = *s++;
    *d++ = *s++;
    *d++ = *s++;
  }
  if (n & 2) {
    *d++ = *s++;
    *d++ = *s++;
  }
  if (n & 1) {
    *d = *s;
  }
  return dest;
#endif

  for (; n; n--)
    *d++ = *s++;
  return dest;
}

int memcmp(const void *vl, const void *vr, size_t n) {
  const unsigned char *l = vl, *r = vr;
  for (; n && *l == *r; n--, l++, r++)
    ;
  return n ? *l - *r : 0;
}

#ifdef __GNUC__
typedef __attribute__((__may_alias__)) size_t WT;
#define WS (sizeof(WT))
#endif

void *memmove(void *dest, const void *src, size_t n) {
  char *d = dest;
  const char *s = src;

  if (d == s)
    return d;
  if ((uintptr_t)s - (uintptr_t)d - n <= -2 * n)
    return memcpy(d, s, n);

  if (d < s) {
#ifdef __GNUC__
    if ((uintptr_t)s % WS == (uintptr_t)d % WS) {
      while ((uintptr_t)d % WS) {
        if (!n--)
          return dest;
        *d++ = *s++;
      }
      for (; n >= WS; n -= WS, d += WS, s += WS)
        *(WT *)d = *(WT *)s;
    }
#endif
    for (; n; n--)
      *d++ = *s++;
  } else {
#ifdef __GNUC__
    if ((uintptr_t)s % WS == (uintptr_t)d % WS) {
      while ((uintptr_t)(d + n) % WS) {
        if (!n--)
          return dest;
        d[n] = s[n];
      }
      while (n >= WS)
        n -= WS, *(WT *)(d + n) = *(WT *)(s + n);
    }
#endif
    while (n)
      n--, d[n] = s[n];
  }

  return dest;
}

#define CKB_SS (sizeof(size_t))
#define CKB_ALIGN (sizeof(size_t) - 1)
#define CKB_ONES ((size_t)-1 / UCHAR_MAX)
#define CKB_HIGHS (CKB_ONES * (UCHAR_MAX / 2 + 1))
#define CKB_HASZERO(x) (((x)-CKB_ONES) & ~(x)&CKB_HIGHS)

void *memchr(const void *src, int c, size_t n) {
  const unsigned char *s = src;
  c = (unsigned char)c;
#ifdef __GNUC__
  for (; ((uintptr_t)s & CKB_ALIGN) && n && *s != c; s++, n--)
    ;
  if (n && *s != c) {
    typedef size_t __attribute__((__may_alias__)) word;
    const word *w;
    size_t k = CKB_ONES * c;
    for (w = (const void *)s; n >= CKB_SS && !CKB_HASZERO(*w ^ k);
         w++, n -= CKB_SS)
      ;
    s = (const void *)w;
  }
#endif
  for (; n && *s != c; s++, n--)
    ;
  return n ? (void *)s : 0;
}

#define BITOP(a, b, op)                                                        \
  ((a)[(size_t)(b) / (8 * sizeof *(a))] op(size_t) 1                           \
   << ((size_t)(b) % (8 * sizeof *(a))))

char *strcpy(char *restrict d, const char *restrict s) {
  char *dest = d;
  for (; (*d = *s); s++, d++)
    ;
  return dest;
}

size_t strlen(const char *s) {
  const char *a = s;
  for (; *s; s++)
    ;
  return s - a;
}

int strcmp(const char *l, const char *r) {
  for (; *l == *r && *l; l++, r++)
    ;
  return *(unsigned char *)l - *(unsigned char *)r;
}

char *__strchrnul(const char *s, int c) {
  c = (unsigned char)c;
  if (!c)
    return (char *)s + strlen(s);

  for (; *s && *(unsigned char *)s != c; s++)
    ;
  return (char *)s;
}

char *strchr(const char *s, int c) {
  char *r = __strchrnul(s, c);
  return *(unsigned char *)r == (unsigned char)c ? r : 0;
}

int strncmp(const char *_l, const char *_r, size_t n) {
  const unsigned char *l = (void *)_l, *r = (void *)_r;
  if (!n--)
    return 0;
  for (; *l && *r && n && *l == *r; l++, r++, n--)
    ;
  return *l - *r;
}

size_t strspn(const char *s, const char *c) {
  const char *a = s;
  size_t byteset[32 / sizeof(size_t)] = {0};

  if (!c[0])
    return 0;
  if (!c[1]) {
    for (; *s == *c; s++)
      ;
    return s - a;
  }

  for (; *c && BITOP(byteset, *(unsigned char *)c, |=); c++)
    ;
  for (; *s && BITOP(byteset, *(unsigned char *)s, &); s++)
    ;
  return s - a;
}

size_t strcspn(const char *s, const char *c) {
  const char *a = s;
  size_t byteset[32 / sizeof(size_t)];

  if (!c[0] || !c[1])
    return __strchrnul(s, *c) - a;

  memset(byteset, 0, sizeof byteset);
  for (; *c && BITOP(byteset, *(unsigned char *)c, |=); c++)
    ;
  for (; *s && !BITOP(byteset, *(unsigned char *)s, &); s++)
    ;
  return s - a;
}

char *strpbrk(const char *s, const char *b) {
  s += strcspn(s, b);
  return *s ? (char *)s : 0;
}

static char *twobyte_strstr(const unsigned char *h, const unsigned char *n) {
  uint16_t nw = n[0] << 8 | n[1], hw = h[0] << 8 | h[1];
  for (h++; *h && hw != nw; hw = hw << 8 | *++h)
    ;
  return *h ? (char *)h - 1 : 0;
}

static char *threebyte_strstr(const unsigned char *h, const unsigned char *n) {
  uint32_t nw = (uint32_t)n[0] << 24 | n[1] << 16 | n[2] << 8;
  uint32_t hw = (uint32_t)h[0] << 24 | h[1] << 16 | h[2] << 8;
  for (h += 2; *h && hw != nw; hw = (hw | *++h) << 8)
    ;
  return *h ? (char *)h - 2 : 0;
}

static char *fourbyte_strstr(const unsigned char *h, const unsigned char *n) {
  uint32_t nw = (uint32_t)n[0] << 24 | n[1] << 16 | n[2] << 8 | n[3];
  uint32_t hw = (uint32_t)h[0] << 24 | h[1] << 16 | h[2] << 8 | h[3];
  for (h += 3; *h && hw != nw; hw = hw << 8 | *++h)
    ;
  return *h ? (char *)h - 3 : 0;
}

#define MAX(a, b) ((a) > (b) ? (a) : (b))
#define MIN(a, b) ((a) < (b) ? (a) : (b))

#define BITOP(a, b, op)                                                        \
  ((a)[(size_t)(b) / (8 * sizeof *(a))] op(size_t) 1                           \
   << ((size_t)(b) % (8 * sizeof *(a))))

static char *twoway_strstr(const unsigned char *h, const unsigned char *n) {
  const unsigned char *z;
  size_t l, ip, jp, k, p, ms, p0, mem, mem0;
  size_t byteset[32 / sizeof(size_t)] = {0};
  size_t shift[256];

  /* Computing length of needle and fill shift table */
  for (l = 0; n[l] && h[l]; l++)
    BITOP(byteset, n[l], |=), shift[n[l]] = l + 1;
  if (n[l])
    return 0; /* hit the end of h */

  /* Compute maximal suffix */
  ip = -1;
  jp = 0;
  k = p = 1;
  while (jp + k < l) {
    if (n[ip + k] == n[jp + k]) {
      if (k == p) {
        jp += p;
        k = 1;
      } else
        k++;
    } else if (n[ip + k] > n[jp + k]) {
      jp += k;
      k = 1;
      p = jp - ip;
    } else {
      ip = jp++;
      k = p = 1;
    }
  }
  ms = ip;
  p0 = p;

  /* And with the opposite comparison */
  ip = -1;
  jp = 0;
  k = p = 1;
  while (jp + k < l) {
    if (n[ip + k] == n[jp + k]) {
      if (k == p) {
        jp += p;
        k = 1;
      } else
        k++;
    } else if (n[ip + k] < n[jp + k]) {
      jp += k;
      k = 1;
      p = jp - ip;
    } else {
      ip = jp++;
      k = p = 1;
    }
  }
  if (ip + 1 > ms + 1)
    ms = ip;
  else
    p = p0;

  /* Periodic needle? */
  if (memcmp(n, n + p, ms + 1)) {
    mem0 = 0;
    p = MAX(ms, l - ms - 1) + 1;
  } else
    mem0 = l - p;
  mem = 0;

  /* Initialize incremental end-of-haystack pointer */
  z = h;

  /* Search loop */
  for (;;) {
    /* Update incremental end-of-haystack pointer */
    if (z - h < l) {
      /* Fast estimate for MAX(l,63) */
      size_t grow = l | 63;
      const unsigned char *z2 = memchr(z, 0, grow);
      if (z2) {
        z = z2;
        if (z - h < l)
          return 0;
      } else
        z += grow;
    }

    /* Check last byte first; advance by shift on mismatch */
    if (BITOP(byteset, h[l - 1], &)) {
      k = l - shift[h[l - 1]];
      if (k) {
        if (k < mem)
          k = mem;
        h += k;
        mem = 0;
        continue;
      }
    } else {
      h += l;
      mem = 0;
      continue;
    }

    /* Compare right half */
    for (k = MAX(ms + 1, mem); n[k] && n[k] == h[k]; k++)
      ;
    if (n[k]) {
      h += k - ms;
      mem = 0;
      continue;
    }
    /* Compare left half */
    for (k = ms + 1; k > mem && n[k - 1] == h[k - 1]; k--)
      ;
    if (k <= mem)
      return (char *)h;
    h += p;
    mem = mem0;
  }
}

char *strstr(const char *h, const char *n) {
  /* Return immediately on empty needle */
  if (!n[0])
    return (char *)h;

  /* Use faster algorithms for short needles */
  h = strchr(h, *n);
  if (!h || !n[1])
    return (char *)h;
  if (!h[1])
    return 0;
  if (!n[2])
    return twobyte_strstr((void *)h, (void *)n);
  if (!h[2])
    return 0;
  if (!n[3])
    return threebyte_strstr((void *)h, (void *)n);
  if (!h[3])
    return 0;
  if (!n[4])
    return fourbyte_strstr((void *)h, (void *)n);

  return twoway_strstr((void *)h, (void *)n);
}

static const struct lconv posix_lconv = {
    .decimal_point = ".",
    .thousands_sep = "",
    .grouping = "",
    .int_curr_symbol = "",
    .currency_symbol = "",
    .mon_decimal_point = "",
    .mon_thousands_sep = "",
    .mon_grouping = "",
    .positive_sign = "",
    .negative_sign = "",
    .int_frac_digits = CHAR_MAX,
    .frac_digits = CHAR_MAX,
    .p_cs_precedes = CHAR_MAX,
    .p_sep_by_space = CHAR_MAX,
    .n_cs_precedes = CHAR_MAX,
    .n_sep_by_space = CHAR_MAX,
    .p_sign_posn = CHAR_MAX,
    .n_sign_posn = CHAR_MAX,
    .int_p_cs_precedes = CHAR_MAX,
    .int_p_sep_by_space = CHAR_MAX,
    .int_n_cs_precedes = CHAR_MAX,
    .int_n_sep_by_space = CHAR_MAX,
    .int_p_sign_posn = CHAR_MAX,
    .int_n_sign_posn = CHAR_MAX,
};

struct lconv *localeconv(void) {
  return (void *)&posix_lconv;
}

#ifdef CKB_C_STDLIB_MALLOC
#include "malloc_impl.h"
#else
void *malloc(size_t size) { return NULL; }
void free(void *ptr) {}
void *calloc(size_t nmemb, size_t size) { return NULL; }
void *realloc(void *ptr, size_t size) { return NULL; }
#endif

/*
 * qsort implementation below is modified from
 * https://git.musl-libc.org/cgit/musl/tree/src/stdlib/qsort.c?id=33338ebc853d37c80f0f236cc7a92cb0acc6aace
 */
/* Copyright (C) 2011 by Valentin Ochs
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 */

/* Minor changes by Rich Felker for integration in musl, 2011-04-27. */

/* Smoothsort, an adaptive variant of Heapsort.  Memory usage: O(1).
   Run time: Worst case O(n log n), close to O(n) in the mostly-sorted case. */

#define ntz(x) a_ctz_l((x))

typedef int (*cmpfun)(const void *, const void *);

static inline int pntz(size_t p[2]) {
  int r = ntz(p[0] - 1);
  if (r != 0 || (r = 8 * sizeof(size_t) + ntz(p[1])) != 8 * sizeof(size_t)) {
    return r;
  }
  return 0;
}

static void cycle(size_t width, unsigned char *ar[], int n) {
  unsigned char tmp[256];
  size_t l;
  int i;

  if (n < 2) {
    return;
  }

  ar[n] = tmp;
  while (width) {
    l = sizeof(tmp) < width ? sizeof(tmp) : width;
    memcpy(ar[n], ar[0], l);
    for (i = 0; i < n; i++) {
      memcpy(ar[i], ar[i + 1], l);
      ar[i] += l;
    }
    width -= l;
  }
}

/* shl() and shr() need n > 0 */
static inline void shl(size_t p[2], int n) {
  if (n >= (int)(8 * sizeof(size_t))) {
    n -= 8 * sizeof(size_t);
    p[1] = p[0];
    p[0] = 0;
  }
  p[1] <<= n;
  p[1] |= p[0] >> (sizeof(size_t) * 8 - n);
  p[0] <<= n;
}

static inline void shr(size_t p[2], int n) {
  if (n >= (int)(8 * sizeof(size_t))) {
    n -= 8 * sizeof(size_t);
    p[0] = p[1];
    p[1] = 0;
  }
  p[0] >>= n;
  p[0] |= p[1] << (sizeof(size_t) * 8 - n);
  p[1] >>= n;
}

static void sift(unsigned char *head, size_t width, cmpfun cmp, int pshift,
                 size_t lp[]) {
  unsigned char *rt, *lf;
  unsigned char *ar[14 * sizeof(size_t) + 1];
  int i = 1;

  ar[0] = head;
  while (pshift > 1) {
    rt = head - width;
    lf = head - width - lp[pshift - 2];

    if ((*cmp)(ar[0], lf) >= 0 && (*cmp)(ar[0], rt) >= 0) {
      break;
    }
    if ((*cmp)(lf, rt) >= 0) {
      ar[i++] = lf;
      head = lf;
      pshift -= 1;
    } else {
      ar[i++] = rt;
      head = rt;
      pshift -= 2;
    }
  }
  cycle(width, ar, i);
}

static void trinkle(unsigned char *head, size_t width, cmpfun cmp, size_t pp[2],
                    int pshift, int trusty, size_t lp[]) {
  unsigned char *stepson, *rt, *lf;
  size_t p[2];
  unsigned char *ar[14 * sizeof(size_t) + 1];
  int i = 1;
  int trail;

  p[0] = pp[0];
  p[1] = pp[1];

  ar[0] = head;
  while (p[0] != 1 || p[1] != 0) {
    stepson = head - lp[pshift];
    if ((*cmp)(stepson, ar[0]) <= 0) {
      break;
    }
    if (!trusty && pshift > 1) {
      rt = head - width;
      lf = head - width - lp[pshift - 2];
      if ((*cmp)(rt, stepson) >= 0 || (*cmp)(lf, stepson) >= 0) {
        break;
      }
    }

    ar[i++] = stepson;
    head = stepson;
    trail = pntz(p);
    shr(p, trail);
    pshift += trail;
    trusty = 0;
  }
  if (!trusty) {
    cycle(width, ar, i);
    sift(head, width, cmp, pshift, lp);
  }
}

void qsort(void *base, size_t nel, size_t width, cmpfun cmp) {
  size_t lp[12 * sizeof(size_t)];
  size_t i, size = width * nel;
  unsigned char *head, *high;
  size_t p[2] = {1, 0};
  int pshift = 1;
  int trail;

  if (!size)
    return;

  head = base;
  high = head + size - width;

  /* Precompute Leonardo numbers, scaled by element width */
  for (lp[0] = lp[1] = width, i = 2;
       (lp[i] = lp[i - 2] + lp[i - 1] + width) < size; i++)
    ;

  while (head < high) {
    if ((p[0] & 3) == 3) {
      sift(head, width, cmp, pshift, lp);
      shr(p, 2);
      pshift += 2;
    } else {
      if (lp[pshift - 1] >= (size_t)(high - head)) {
        trinkle(head, width, cmp, p, pshift, 0, lp);
      } else {
        sift(head, width, cmp, pshift, lp);
      }

      if (pshift == 1) {
        shl(p, 1);
        pshift = 0;
      } else {
        shl(p, pshift - 1);
        pshift = 1;
      }
    }

    p[0] |= 1;
    head += width;
  }

  trinkle(head, width, cmp, p, pshift, 0, lp);

  while (pshift != 1 || p[0] != 1 || p[1] != 0) {
    if (pshift <= 1) {
      trail = pntz(p);
      shr(p, trail);
      pshift += trail;
    } else {
      shl(p, 2);
      pshift -= 2;
      p[0] ^= 7;
      shr(p, 1);
      trinkle(head - lp[pshift] - width, width, cmp, p, pshift + 1, 1, lp);
      shl(p, 1);
      p[0] |= 1;
      trinkle(head - width, width, cmp, p, pshift, 1, lp);
    }
    head -= width;
  }
}

//  bsearch implementation below is modified from
// http://git.musl-libc.org/cgit/musl/tree/src/stdlib/bsearch.c
void *bsearch(const void *key, const void *base, size_t nel, size_t width,
              int (*cmp)(const void *, const void *)) {
  void *try_v;
  int sign;
  while (nel > 0) {
    try_v = (char *)base + width * (nel / 2);
    sign = cmp(key, try_v);
    if (sign < 0) {
      nel /= 2;
    } else if (sign > 0) {
      base = (char *)try_v + width;
      nel -= nel / 2 + 1;
    } else {
      return try_v;
    }
  }
  return NULL;
}

// printf, pass -D CKB_C_STDLIB_PRINTF to enable printf
// default: disabled
#ifdef CKB_C_STDLIB_PRINTF

// Default PRINTF_BUFFER_SIZE
#ifndef CKB_C_STDLIB_PRINTF_BUFFER_SIZE
#define CKB_C_STDLIB_PRINTF_BUFFER_SIZE 256
#endif

// define this globally (e.g. gcc -DPRINTF_INCLUDE_CONFIG_H ...) to include the
// printf_config.h header file
// default: undefined
#ifdef PRINTF_INCLUDE_CONFIG_H
#include "printf_config.h"
#endif

// 'ntoa' conversion buffer size, this must be big enough to hold one converted
// numeric number including padded zeros (dynamically created on stack)
// default: 32 byte
#ifndef PRINTF_NTOA_BUFFER_SIZE
#define PRINTF_NTOA_BUFFER_SIZE 32U
#endif

// 'ftoa' conversion buffer size, this must be big enough to hold one converted
// float number including padded zeros (dynamically created on stack)
// default: 32 byte
#ifndef PRINTF_FTOA_BUFFER_SIZE
#define PRINTF_FTOA_BUFFER_SIZE 32U
#endif

// support for the floating point type (%f)
// default: activated
#ifndef PRINTF_DISABLE_SUPPORT_FLOAT
#define PRINTF_SUPPORT_FLOAT
#endif

// support for exponential floating point notation (%e/%g)
// default: activated
#ifndef PRINTF_DISABLE_SUPPORT_EXPONENTIAL
#define PRINTF_SUPPORT_EXPONENTIAL
#endif

// define the default floating point precision
// default: 6 digits
#ifndef PRINTF_DEFAULT_FLOAT_PRECISION
#define PRINTF_DEFAULT_FLOAT_PRECISION 6U
#endif

// define the largest float suitable to print with %f
// default: 1e9
#ifndef PRINTF_MAX_FLOAT
#define PRINTF_MAX_FLOAT 1e9
#endif

// support for the long long types (%llu or %p)
// default: activated
#ifndef PRINTF_DISABLE_SUPPORT_LONG_LONG
#define PRINTF_SUPPORT_LONG_LONG
#endif

// support for the ptrdiff_t type (%t)
// ptrdiff_t is normally defined in <stddef.h> as long or long long type
// default: disabled
#ifndef PRINTF_DISABLE_SUPPORT_PTRDIFF_T
#endif

///////////////////////////////////////////////////////////////////////////////

// internal flag definitions
#define FLAGS_ZEROPAD (1U << 0U)
#define FLAGS_LEFT (1U << 1U)
#define FLAGS_PLUS (1U << 2U)
#define FLAGS_SPACE (1U << 3U)
#define FLAGS_HASH (1U << 4U)
#define FLAGS_UPPERCASE (1U << 5U)
#define FLAGS_CHAR (1U << 6U)
#define FLAGS_SHORT (1U << 7U)
#define FLAGS_LONG (1U << 8U)
#define FLAGS_LONG_LONG (1U << 9U)
#define FLAGS_PRECISION (1U << 10U)
#define FLAGS_ADAPT_EXP (1U << 11U)

// output function type
typedef void (*out_fct_type)(char character, void *buffer, size_t idx,
                             size_t maxlen);

// wrapper (used as buffer) for output function type
typedef struct {
  void (*fct)(char character, void *arg);
  void *arg;
} out_fct_wrap_type;

// internal buffer output
static inline void _out_buffer(char character, void *buffer, size_t idx,
                               size_t maxlen) {
  if (idx < maxlen) {
    ((char *)buffer)[idx] = character;
  }
}

// internal null output
static inline void _out_null(char character, void *buffer, size_t idx,
                             size_t maxlen) {
  (void)character;
  (void)buffer;
  (void)idx;
  (void)maxlen;
}

// internal output function wrapper
static inline void _out_fct(char character, void *buffer, size_t idx,
                            size_t maxlen) {
  (void)idx;
  (void)maxlen;
  if (character) {
    // buffer is the output fct pointer
    ((out_fct_wrap_type *)buffer)
        ->fct(character, ((out_fct_wrap_type *)buffer)->arg);
  }
}

// internal secure strlen
// \return The length of the string (excluding the terminating 0) limited by
// 'maxsize'
static inline unsigned int _strnlen_s(const char *str, size_t maxsize) {
  const char *s;
  for (s = str; *s && maxsize--; ++s)
    ;
  return (unsigned int)(s - str);
}

// internal test if char is a digit (0-9)
// \return true if char is a digit
static inline bool _is_digit(char ch) { return (ch >= '0') && (ch <= '9'); }

// internal ASCII string to unsigned int conversion
static unsigned int _atoi(const char **str) {
  unsigned int i = 0U;
  while (_is_digit(**str)) {
    i = i * 10U + (unsigned int)(*((*str)++) - '0');
  }
  return i;
}

// output the specified string in reverse, taking care of any zero-padding
static size_t _out_rev(out_fct_type out, char *buffer, size_t idx,
                       size_t maxlen, const char *buf, size_t len,
                       unsigned int width, unsigned int flags) {
  const size_t start_idx = idx;

  // pad spaces up to given width
  if (!(flags & FLAGS_LEFT) && !(flags & FLAGS_ZEROPAD)) {
    for (size_t i = len; i < width; i++) {
      out(' ', buffer, idx++, maxlen);
    }
  }

  // reverse string
  while (len) {
    out(buf[--len], buffer, idx++, maxlen);
  }

  // append pad spaces up to given width
  if (flags & FLAGS_LEFT) {
    while (idx - start_idx < width) {
      out(' ', buffer, idx++, maxlen);
    }
  }

  return idx;
}

// internal itoa format
static size_t _ntoa_format(out_fct_type out, char *buffer, size_t idx,
                           size_t maxlen, char *buf, size_t len, bool negative,
                           unsigned int base, unsigned int prec,
                           unsigned int width, unsigned int flags) {
  // pad leading zeros
  if (!(flags & FLAGS_LEFT)) {
    if (width && (flags & FLAGS_ZEROPAD) &&
        (negative || (flags & (FLAGS_PLUS | FLAGS_SPACE)))) {
      width--;
    }
    while ((len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
      buf[len++] = '0';
    }
    while ((flags & FLAGS_ZEROPAD) && (len < width) &&
           (len < PRINTF_NTOA_BUFFER_SIZE)) {
      buf[len++] = '0';
    }
  }

  // handle hash
  if (flags & FLAGS_HASH) {
    if (!(flags & FLAGS_PRECISION) && len &&
        ((len == prec) || (len == width))) {
      len--;
      if (len && (base == 16U)) {
        len--;
      }
    }
    if ((base == 16U) && !(flags & FLAGS_UPPERCASE) &&
        (len < PRINTF_NTOA_BUFFER_SIZE)) {
      buf[len++] = 'x';
    } else if ((base == 16U) && (flags & FLAGS_UPPERCASE) &&
               (len < PRINTF_NTOA_BUFFER_SIZE)) {
      buf[len++] = 'X';
    } else if ((base == 2U) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
      buf[len++] = 'b';
    }
    if (len < PRINTF_NTOA_BUFFER_SIZE) {
      buf[len++] = '0';
    }
  }

  if (len < PRINTF_NTOA_BUFFER_SIZE) {
    if (negative) {
      buf[len++] = '-';
    } else if (flags & FLAGS_PLUS) {
      buf[len++] = '+'; // ignore the space if the '+' exists
    } else if (flags & FLAGS_SPACE) {
      buf[len++] = ' ';
    }
  }

  return _out_rev(out, buffer, idx, maxlen, buf, len, width, flags);
}

// internal itoa for 'long' type
static size_t _ntoa_long(out_fct_type out, char *buffer, size_t idx,
                         size_t maxlen, unsigned long value, bool negative,
                         unsigned long base, unsigned int prec,
                         unsigned int width, unsigned int flags) {
  char buf[PRINTF_NTOA_BUFFER_SIZE];
  size_t len = 0U;

  // no hash for 0 values
  if (!value) {
    flags &= ~FLAGS_HASH;
  }

  // write if precision != 0 and value is != 0
  if (!(flags & FLAGS_PRECISION) || value) {
    do {
      const char digit = (char)(value % base);
      buf[len++] = digit < 10
                       ? '0' + digit
                       : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
      value /= base;
    } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
  }

  return _ntoa_format(out, buffer, idx, maxlen, buf, len, negative,
                      (unsigned int)base, prec, width, flags);
}

// internal itoa for 'long long' type
#if defined(PRINTF_SUPPORT_LONG_LONG)
static size_t _ntoa_long_long(out_fct_type out, char *buffer, size_t idx,
                              size_t maxlen, unsigned long long value,
                              bool negative, unsigned long long base,
                              unsigned int prec, unsigned int width,
                              unsigned int flags) {
  char buf[PRINTF_NTOA_BUFFER_SIZE];
  size_t len = 0U;

  // no hash for 0 values
  if (!value) {
    flags &= ~FLAGS_HASH;
  }

  // write if precision != 0 and value is != 0
  if (!(flags & FLAGS_PRECISION) || value) {
    do {
      const char digit = (char)(value % base);
      buf[len++] = digit < 10
                       ? '0' + digit
                       : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
      value /= base;
    } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
  }

  return _ntoa_format(out, buffer, idx, maxlen, buf, len, negative,
                      (unsigned int)base, prec, width, flags);
}
#endif // PRINTF_SUPPORT_LONG_LONG

#if defined(PRINTF_SUPPORT_FLOAT)

#if defined(PRINTF_SUPPORT_EXPONENTIAL)
// forward declaration so that _ftoa can switch to exp notation for values >
// PRINTF_MAX_FLOAT
static size_t _etoa(out_fct_type out, char *buffer, size_t idx, size_t maxlen,
                    double value, unsigned int prec, unsigned int width,
                    unsigned int flags);
#endif

// internal ftoa for fixed decimal floating point
static size_t _ftoa(out_fct_type out, char *buffer, size_t idx, size_t maxlen,
                    double value, unsigned int prec, unsigned int width,
                    unsigned int flags) {
  char buf[PRINTF_FTOA_BUFFER_SIZE];
  size_t len = 0U;
  double diff = 0.0;

  // powers of 10
  static const double pow10[] = {1,         10,        100,     1000,
                                 10000,     100000,    1000000, 10000000,
                                 100000000, 1000000000};

  // test for special values
  if (value != value)
    return _out_rev(out, buffer, idx, maxlen, "nan", 3, width, flags);
  if (value < -DBL_MAX)
    return _out_rev(out, buffer, idx, maxlen, "fni-", 4, width, flags);
  if (value > DBL_MAX)
    return _out_rev(out, buffer, idx, maxlen,
                    (flags & FLAGS_PLUS) ? "fni+" : "fni",
                    (flags & FLAGS_PLUS) ? 4U : 3U, width, flags);

  // test for very large values
  // standard printf behavior is to print EVERY whole number digit -- which
  // could be 100s of characters overflowing your buffers == bad
  if ((value > PRINTF_MAX_FLOAT) || (value < -PRINTF_MAX_FLOAT)) {
#if defined(PRINTF_SUPPORT_EXPONENTIAL)
    return _etoa(out, buffer, idx, maxlen, value, prec, width, flags);
#else
    return 0U;
#endif
  }

  // test for negative
  bool negative = false;
  if (value < 0) {
    negative = true;
    value = 0 - value;
  }

  // set default precision, if not set explicitly
  if (!(flags & FLAGS_PRECISION)) {
    prec = PRINTF_DEFAULT_FLOAT_PRECISION;
  }
  // limit precision to 9, cause a prec >= 10 can lead to overflow errors
  while ((len < PRINTF_FTOA_BUFFER_SIZE) && (prec > 9U)) {
    buf[len++] = '0';
    prec--;
  }

  int whole = (int)value;
  double tmp = (value - whole) * pow10[prec];
  unsigned long frac = (unsigned long)tmp;
  diff = tmp - frac;

  if (diff > 0.5) {
    ++frac;
    // handle rollover, e.g. case 0.99 with prec 1 is 1.0
    if (frac >= pow10[prec]) {
      frac = 0;
      ++whole;
    }
  } else if (diff < 0.5) {
  } else if ((frac == 0U) || (frac & 1U)) {
    // if halfway, round up if odd OR if last digit is 0
    ++frac;
  }

  if (prec == 0U) {
    diff = value - (double)whole;
    if ((!(diff < 0.5) || (diff > 0.5)) && (whole & 1)) {
      // exactly 0.5 and ODD, then round up
      // 1.5 -> 2, but 2.5 -> 2
      ++whole;
    }
  } else {
    unsigned int count = prec;
    // now do fractional part, as an unsigned number
    while (len < PRINTF_FTOA_BUFFER_SIZE) {
      --count;
      buf[len++] = (char)(48U + (frac % 10U));
      if (!(frac /= 10U)) {
        break;
      }
    }
    // add extra 0s
    while ((len < PRINTF_FTOA_BUFFER_SIZE) && (count-- > 0U)) {
      buf[len++] = '0';
    }
    if (len < PRINTF_FTOA_BUFFER_SIZE) {
      // add decimal
      buf[len++] = '.';
    }
  }

  // do whole part, number is reversed
  while (len < PRINTF_FTOA_BUFFER_SIZE) {
    buf[len++] = (char)(48 + (whole % 10));
    if (!(whole /= 10)) {
      break;
    }
  }

  // pad leading zeros
  if (!(flags & FLAGS_LEFT) && (flags & FLAGS_ZEROPAD)) {
    if (width && (negative || (flags & (FLAGS_PLUS | FLAGS_SPACE)))) {
      width--;
    }
    while ((len < width) && (len < PRINTF_FTOA_BUFFER_SIZE)) {
      buf[len++] = '0';
    }
  }

  if (len < PRINTF_FTOA_BUFFER_SIZE) {
    if (negative) {
      buf[len++] = '-';
    } else if (flags & FLAGS_PLUS) {
      buf[len++] = '+'; // ignore the space if the '+' exists
    } else if (flags & FLAGS_SPACE) {
      buf[len++] = ' ';
    }
  }

  return _out_rev(out, buffer, idx, maxlen, buf, len, width, flags);
}

#if defined(PRINTF_SUPPORT_EXPONENTIAL)
// internal ftoa variant for exponential floating-point type, contributed by
// Martijn Jasperse <m.jasperse@gmail.com>
static size_t _etoa(out_fct_type out, char *buffer, size_t idx, size_t maxlen,
                    double value, unsigned int prec, unsigned int width,
                    unsigned int flags) {
  // check for NaN and special values
  if ((value != value) || (value > DBL_MAX) || (value < -DBL_MAX)) {
    return _ftoa(out, buffer, idx, maxlen, value, prec, width, flags);
  }

  // determine the sign
  const bool negative = value < 0;
  if (negative) {
    value = -value;
  }

  // default precision
  if (!(flags & FLAGS_PRECISION)) {
    prec = PRINTF_DEFAULT_FLOAT_PRECISION;
  }

  // determine the decimal exponent
  // based on the algorithm by David Gay (https://www.ampl.com/netlib/fp/dtoa.c)
  union {
    uint64_t U;
    double F;
  } conv;

  conv.F = value;
  int exp2 = (int)((conv.U >> 52U) & 0x07FFU) - 1023; // effectively log2
  conv.U = (conv.U & ((1ULL << 52U) - 1U)) |
           (1023ULL << 52U); // drop the exponent so conv.F is now in [1,2)
  // now approximate log10 from the log2 integer part and an expansion of ln
  // around 1.5
  int expval = (int)(0.1760912590558 + exp2 * 0.301029995663981 +
                     (conv.F - 1.5) * 0.289529654602168);
  // now we want to compute 10^expval but we want to be sure it won't overflow
  exp2 = (int)(expval * 3.321928094887362 + 0.5);
  const double z = expval * 2.302585092994046 - exp2 * 0.6931471805599453;
  const double z2 = z * z;
  conv.U = (uint64_t)(exp2 + 1023) << 52U;
  // compute exp(z) using continued fractions, see
  // https://en.wikipedia.org/wiki/Exponential_function#Continued_fractions_for_ex
  conv.F *= 1 + 2 * z / (2 - z + (z2 / (6 + (z2 / (10 + z2 / 14)))));
  // correct for rounding errors
  if (value < conv.F) {
    expval--;
    conv.F /= 10;
  }

  // the exponent format is "%+03d" and largest value is "307", so set aside 4-5
  // characters
  unsigned int minwidth = ((expval < 100) && (expval > -100)) ? 4U : 5U;

  // in "%g" mode, "prec" is the number of *significant figures* not decimals
  if (flags & FLAGS_ADAPT_EXP) {
    // do we want to fall-back to "%f" mode?
    if ((value >= 1e-4) && (value < 1e6)) {
      if ((int)prec > expval) {
        prec = (unsigned)((int)prec - expval - 1);
      } else {
        prec = 0;
      }
      flags |= FLAGS_PRECISION; // make sure _ftoa respects precision
      // no characters in exponent
      minwidth = 0U;
      expval = 0;
    } else {
      // we use one sigfig for the whole part
      if ((prec > 0) && (flags & FLAGS_PRECISION)) {
        --prec;
      }
    }
  }

  // will everything fit?
  unsigned int fwidth = width;
  if (width > minwidth) {
    // we didn't fall-back so subtract the characters required for the exponent
    fwidth -= minwidth;
  } else {
    // not enough characters, so go back to default sizing
    fwidth = 0U;
  }
  if ((flags & FLAGS_LEFT) && minwidth) {
    // if we're padding on the right, DON'T pad the floating part
    fwidth = 0U;
  }

  // rescale the float value
  if (expval) {
    value /= conv.F;
  }

  // output the floating part
  const size_t start_idx = idx;
  idx = _ftoa(out, buffer, idx, maxlen, negative ? -value : value, prec, fwidth,
              flags & ~FLAGS_ADAPT_EXP);

  // output the exponent part
  if (minwidth) {
    // output the exponential symbol
    out((flags & FLAGS_UPPERCASE) ? 'E' : 'e', buffer, idx++, maxlen);
    // output the exponent value
    idx =
        _ntoa_long(out, buffer, idx, maxlen, (expval < 0) ? -expval : expval,
                   expval < 0, 10, 0, minwidth - 1, FLAGS_ZEROPAD | FLAGS_PLUS);
    // might need to right-pad spaces
    if (flags & FLAGS_LEFT) {
      while (idx - start_idx < width)
        out(' ', buffer, idx++, maxlen);
    }
  }
  return idx;
}
#endif // PRINTF_SUPPORT_EXPONENTIAL
#endif // PRINTF_SUPPORT_FLOAT

// internal vsnprintf
static int _vsnprintf(out_fct_type out, char *buffer, const size_t maxlen,
                      const char *format, va_list va) {
  unsigned int flags, width, precision, n;
  size_t idx = 0U;

  if (!buffer) {
    // use null output function
    out = _out_null;
  }

  while (*format) {
    // format specifier?  %[flags][width][.precision][length]
    if (*format != '%') {
      // no
      out(*format, buffer, idx++, maxlen);
      format++;
      continue;
    } else {
      // yes, evaluate it
      format++;
    }

    // evaluate flags
    flags = 0U;
    do {
      switch (*format) {
      case '0':
        flags |= FLAGS_ZEROPAD;
        format++;
        n = 1U;
        break;
      case '-':
        flags |= FLAGS_LEFT;
        format++;
        n = 1U;
        break;
      case '+':
        flags |= FLAGS_PLUS;
        format++;
        n = 1U;
        break;
      case ' ':
        flags |= FLAGS_SPACE;
        format++;
        n = 1U;
        break;
      case '#':
        flags |= FLAGS_HASH;
        format++;
        n = 1U;
        break;
      default:
        n = 0U;
        break;
      }
    } while (n);

    // evaluate width field
    width = 0U;
    if (_is_digit(*format)) {
      width = _atoi(&format);
    } else if (*format == '*') {
      const int w = va_arg(va, int);
      if (w < 0) {
        flags |= FLAGS_LEFT; // reverse padding
        width = (unsigned int)-w;
      } else {
        width = (unsigned int)w;
      }
      format++;
    }

    // evaluate precision field
    precision = 0U;
    if (*format == '.') {
      flags |= FLAGS_PRECISION;
      format++;
      if (_is_digit(*format)) {
        precision = _atoi(&format);
      } else if (*format == '*') {
        const int prec = (int)va_arg(va, int);
        precision = prec > 0 ? (unsigned int)prec : 0U;
        format++;
      }
    }

    // evaluate length field
    switch (*format) {
    case 'l':
      flags |= FLAGS_LONG;
      format++;
      if (*format == 'l') {
        flags |= FLAGS_LONG_LONG;
        format++;
      }
      break;
    case 'h':
      flags |= FLAGS_SHORT;
      format++;
      if (*format == 'h') {
        flags |= FLAGS_CHAR;
        format++;
      }
      break;
#if defined(PRINTF_SUPPORT_PTRDIFF_T)
    case 't':
      flags |=
          (sizeof(ptrdiff_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG);
      format++;
      break;
#endif
    case 'j':
      flags |=
          (sizeof(uint64_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG);
      format++;
      break;
    case 'z':
      flags |= (sizeof(size_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG);
      format++;
      break;
    default:
      break;
    }

    // evaluate specifier
    switch (*format) {
    case 'd':
    case 'i':
    case 'u':
    case 'x':
    case 'X':
    case 'o':
    case 'b': {
      // set the base
      unsigned int base;
      if (*format == 'x' || *format == 'X') {
        base = 16U;
      } else if (*format == 'o') {
        base = 8U;
      } else if (*format == 'b') {
        base = 2U;
      } else {
        base = 10U;
        flags &= ~FLAGS_HASH; // no hash for dec format
      }
      // uppercase
      if (*format == 'X') {
        flags |= FLAGS_UPPERCASE;
      }

      // no plus or space flag for u, x, X, o, b
      if ((*format != 'i') && (*format != 'd')) {
        flags &= ~(FLAGS_PLUS | FLAGS_SPACE);
      }

      // ignore '0' flag when precision is given
      if (flags & FLAGS_PRECISION) {
        flags &= ~FLAGS_ZEROPAD;
      }

      // convert the integer
      if ((*format == 'i') || (*format == 'd')) {
        // signed
        if (flags & FLAGS_LONG_LONG) {
#if defined(PRINTF_SUPPORT_LONG_LONG)
          const long long value = va_arg(va, long long);
          idx = _ntoa_long_long(
              out, buffer, idx, maxlen,
              (unsigned long long)(value > 0 ? value : 0 - value), value < 0,
              base, precision, width, flags);
#endif
        } else if (flags & FLAGS_LONG) {
          const long value = va_arg(va, long);
          idx = _ntoa_long(out, buffer, idx, maxlen,
                           (unsigned long)(value > 0 ? value : 0 - value),
                           value < 0, base, precision, width, flags);
        } else {
          const int value = (flags & FLAGS_CHAR)    ? (char)va_arg(va, int)
                            : (flags & FLAGS_SHORT) ? (short int)va_arg(va, int)
                                                    : va_arg(va, int);
          idx = _ntoa_long(out, buffer, idx, maxlen,
                           (unsigned int)(value > 0 ? value : 0 - value),
                           value < 0, base, precision, width, flags);
        }
      } else {
        // unsigned
        if (flags & FLAGS_LONG_LONG) {
#if defined(PRINTF_SUPPORT_LONG_LONG)
          idx = _ntoa_long_long(out, buffer, idx, maxlen,
                                va_arg(va, unsigned long long), false, base,
                                precision, width, flags);
#endif
        } else if (flags & FLAGS_LONG) {
          idx = _ntoa_long(out, buffer, idx, maxlen, va_arg(va, unsigned long),
                           false, base, precision, width, flags);
        } else {
          const unsigned int value =
              (flags & FLAGS_CHAR) ? (unsigned char)va_arg(va, unsigned int)
              : (flags & FLAGS_SHORT)
                  ? (unsigned short int)va_arg(va, unsigned int)
                  : va_arg(va, unsigned int);
          idx = _ntoa_long(out, buffer, idx, maxlen, value, false, base,
                           precision, width, flags);
        }
      }
      format++;
      break;
    }
#if defined(PRINTF_SUPPORT_FLOAT)
    case 'f':
    case 'F':
      if (*format == 'F')
        flags |= FLAGS_UPPERCASE;
      idx = _ftoa(out, buffer, idx, maxlen, va_arg(va, double), precision,
                  width, flags);
      format++;
      break;
#if defined(PRINTF_SUPPORT_EXPONENTIAL)
    case 'e':
    case 'E':
    case 'g':
    case 'G':
      if ((*format == 'g') || (*format == 'G'))
        flags |= FLAGS_ADAPT_EXP;
      if ((*format == 'E') || (*format == 'G'))
        flags |= FLAGS_UPPERCASE;
      idx = _etoa(out, buffer, idx, maxlen, va_arg(va, double), precision,
                  width, flags);
      format++;
      break;
#endif // PRINTF_SUPPORT_EXPONENTIAL
#endif // PRINTF_SUPPORT_FLOAT
    case 'c': {
      unsigned int l = 1U;
      // pre padding
      if (!(flags & FLAGS_LEFT)) {
        while (l++ < width) {
          out(' ', buffer, idx++, maxlen);
        }
      }
      // char output
      out((char)va_arg(va, int), buffer, idx++, maxlen);
      // post padding
      if (flags & FLAGS_LEFT) {
        while (l++ < width) {
          out(' ', buffer, idx++, maxlen);
        }
      }
      format++;
      break;
    }

    case 's': {
      const char *p = va_arg(va, char *);
      unsigned int l = _strnlen_s(p, precision ? precision : (size_t)-1);
      // pre padding
      if (flags & FLAGS_PRECISION) {
        l = (l < precision ? l : precision);
      }
      if (!(flags & FLAGS_LEFT)) {
        while (l++ < width) {
          out(' ', buffer, idx++, maxlen);
        }
      }
      // string output
      while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {
        out(*(p++), buffer, idx++, maxlen);
      }
      // post padding
      if (flags & FLAGS_LEFT) {
        while (l++ < width) {
          out(' ', buffer, idx++, maxlen);
        }
      }
      format++;
      break;
    }

    case 'p': {
      width = sizeof(void *) * 2U;
      flags |= FLAGS_ZEROPAD | FLAGS_UPPERCASE;
#if defined(PRINTF_SUPPORT_LONG_LONG)
      const bool is_ll = sizeof(uintptr_t) == sizeof(long long);
      if (is_ll) {
        idx = _ntoa_long_long(out, buffer, idx, maxlen,
                              (uintptr_t)va_arg(va, void *), false, 16U,
                              precision, width, flags);
      } else {
#endif
        idx = _ntoa_long(out, buffer, idx, maxlen,
                         (unsigned long)((uintptr_t)va_arg(va, void *)), false,
                         16U, precision, width, flags);
#if defined(PRINTF_SUPPORT_LONG_LONG)
      }
#endif
      format++;
      break;
    }

    case '%':
      out('%', buffer, idx++, maxlen);
      format++;
      break;

    default:
      out(*format, buffer, idx++, maxlen);
      format++;
      break;
    }
  }

  // termination
  out((char)0, buffer, idx < maxlen ? idx : maxlen - 1U, maxlen);

  // return written chars without terminating \0
  return (int)idx;
}

///////////////////////////////////////////////////////////////////////////////

int sprintf_(char *buffer, const char *format, ...) {
  va_list va;
  va_start(va, format);
  const int ret = _vsnprintf(_out_buffer, buffer, (size_t)-1, format, va);
  va_end(va);
  return ret;
}

int snprintf_(char *buffer, size_t count, const char *format, ...) {
  va_list va;
  va_start(va, format);
  const int ret = _vsnprintf(_out_buffer, buffer, count, format, va);
  va_end(va);
  return ret;
}

int vsnprintf_(char *buffer, size_t count, const char *format, va_list va) {
  return _vsnprintf(_out_buffer, buffer, count, format, va);
}

int fctprintf(void (*out)(char character, void *arg), void *arg,
              const char *format, ...) {
  va_list va;
  va_start(va, format);
  const out_fct_wrap_type out_fct_wrap = {out, arg};
  const int ret = _vsnprintf(_out_fct, (char *)(uintptr_t)&out_fct_wrap,
                             (size_t)-1, format, va);
  va_end(va);
  return ret;
}

// syscall
int ckb_debug(const char *s);
int printf(const char *format, ...) {
  static char buf[CKB_C_STDLIB_PRINTF_BUFFER_SIZE];
  va_list va;
  va_start(va, format);
  int ret = vsnprintf_(buf, CKB_C_STDLIB_PRINTF_BUFFER_SIZE, format, va);
  va_end(va);
  ckb_debug(buf);
  return ret;
}
int ckb_printf(const char *format, ...) {
  static char buf[CKB_C_STDLIB_PRINTF_BUFFER_SIZE];
  va_list va;
  va_start(va, format);
  int ret = vsnprintf_(buf, CKB_C_STDLIB_PRINTF_BUFFER_SIZE, format, va);
  va_end(va);
  ckb_debug(buf);
  return ret;
}

#else

int printf(const char *format, ...) { return 0; }
int ckb_printf(const char *format, ...) { return 0; }

#endif /* CKB_C_STDLIB_PRINTF */

/* Copied from
 * https://github.com/bminor/musl/blob/46d1c7801bb509e1097e8fadbaf359367fa4ef0b/src/setjmp/riscv64/setjmp.S
 */
/* We need to use inline asm for easier compilation,
 * https://stackoverflow.com/a/42358235. */
/* We need __attribute__((naked)) to remove prologue and epilogue,
 * https://stackoverflow.com/a/42637729 */
__attribute__((naked)) int setjmp(jmp_buf b) {
  asm volatile("sd s0,    0(a0)\n"
               "sd s1,    8(a0)\n"
               "sd s2,    16(a0)\n"
               "sd s3,    24(a0)\n"
               "sd s4,    32(a0)\n"
               "sd s5,    40(a0)\n"
               "sd s6,    48(a0)\n"
               "sd s7,    56(a0)\n"
               "sd s8,    64(a0)\n"
               "sd s9,    72(a0)\n"
               "sd s10,   80(a0)\n"
               "sd s11,   88(a0)\n"
               "sd sp,    96(a0)\n"
               "sd ra,    104(a0)\n"
               "li a0, 0\n"
               "ret\n");
}

__attribute__((naked)) int _setjmp(jmp_buf b) {
  asm volatile("sd s0,    0(a0)\n"
               "sd s1,    8(a0)\n"
               "sd s2,    16(a0)\n"
               "sd s3,    24(a0)\n"
               "sd s4,    32(a0)\n"
               "sd s5,    40(a0)\n"
               "sd s6,    48(a0)\n"
               "sd s7,    56(a0)\n"
               "sd s8,    64(a0)\n"
               "sd s9,    72(a0)\n"
               "sd s10,   80(a0)\n"
               "sd s11,   88(a0)\n"
               "sd sp,    96(a0)\n"
               "sd ra,    104(a0)\n"
               "li a0, 0\n"
               "ret\n");
}

__attribute__((naked)) void longjmp(jmp_buf b, int n) {
  asm volatile("ld s0,    0(a0)\n"
               "ld s1,    8(a0)\n"
               "ld s2,    16(a0)\n"
               "ld s3,    24(a0)\n"
               "ld s4,    32(a0)\n"
               "ld s5,    40(a0)\n"
               "ld s6,    48(a0)\n"
               "ld s7,    56(a0)\n"
               "ld s8,    64(a0)\n"
               "ld s9,    72(a0)\n"
               "ld s10,   80(a0)\n"
               "ld s11,   88(a0)\n"
               "ld sp,    96(a0)\n"
               "ld ra,    104(a0)\n"
               "seqz a0, a1\n"
               "add a0, a0, a1\n"
               "ret\n");
}

__attribute__((naked)) void _longjmp(jmp_buf b, int n) {
  asm volatile("ld s0,    0(a0)\n"
               "ld s1,    8(a0)\n"
               "ld s2,    16(a0)\n"
               "ld s3,    24(a0)\n"
               "ld s4,    32(a0)\n"
               "ld s5,    40(a0)\n"
               "ld s6,    48(a0)\n"
               "ld s7,    56(a0)\n"
               "ld s8,    64(a0)\n"
               "ld s9,    72(a0)\n"
               "ld s10,   80(a0)\n"
               "ld s11,   88(a0)\n"
               "ld sp,    96(a0)\n"
               "ld ra,    104(a0)\n"
               "seqz a0, a1\n"
               "add a0, a0, a1\n"
               "ret\n");
}

int abs(int a) { return a > 0 ? a : -a; }

double frexp(double x, int *e) {
  union {
    double d;
    uint64_t i;
  } y = {x};
  int ee = y.i >> 52 & 0x7ff;

  if (!ee) {
    if (x) {
      x = frexp(x * 0x1p64, e);
      *e -= 64;
    } else
      *e = 0;
    return x;
  } else if (ee == 0x7ff) {
    return x;
  }

  *e = ee - 0x3fe;
  y.i &= 0x800fffffffffffffull;
  y.i |= 0x3fe0000000000000ull;
  return y.d;
}

double fmod(double x, double y) {
  union {
    double f;
    uint64_t i;
  } ux = {x}, uy = {y};
  int ex = ux.i >> 52 & 0x7ff;
  int ey = uy.i >> 52 & 0x7ff;
  int sx = ux.i >> 63;
  uint64_t i;

  /* in the followings uxi should be ux.i, but then gcc wrongly adds */
  /* float load/store to inner loops ruining performance and code size */
  uint64_t uxi = ux.i;

  if (uy.i << 1 == 0 || __builtin_isnan(y) || ex == 0x7ff)
    return (x * y) / (x * y);
  if (uxi << 1 <= uy.i << 1) {
    if (uxi << 1 == uy.i << 1)
      return 0 * x;
    return x;
  }

  /* normalize x and y */
  if (!ex) {
    for (i = uxi << 12; i >> 63 == 0; ex--, i <<= 1)
      ;
    uxi <<= -ex + 1;
  } else {
    uxi &= -1ULL >> 12;
    uxi |= 1ULL << 52;
  }
  if (!ey) {
    for (i = uy.i << 12; i >> 63 == 0; ey--, i <<= 1)
      ;
    uy.i <<= -ey + 1;
  } else {
    uy.i &= -1ULL >> 12;
    uy.i |= 1ULL << 52;
  }

  /* x mod y */
  for (; ex > ey; ex--) {
    i = uxi - uy.i;
    if (i >> 63 == 0) {
      if (i == 0)
        return 0 * x;
      uxi = i;
    }
    uxi <<= 1;
  }
  i = uxi - uy.i;
  if (i >> 63 == 0) {
    if (i == 0)
      return 0 * x;
    uxi = i;
  }
  for (; uxi >> 52 == 0; uxi <<= 1, ex--)
    ;

  /* scale result */
  if (ex > 0) {
    uxi -= 1ULL << 52;
    uxi |= (uint64_t)ex << 52;
  } else {
    uxi >>= -ex + 1;
  }
  uxi |= (uint64_t)sx << 63;
  ux.i = uxi;
  return ux.f;
}

int strcoll(const char *l, const char *r) { return strcmp(l, r); }

int *__errno_location(void) {
  static int error = -1;
  return &error;
}

char *strerror(int e) {
  static char *errorstr = "There is an error";
  return errorstr;
}

int islower(int c) { return (unsigned)c - 'a' < 26; }

int isupper(int c) { return (unsigned)c - 'A' < 26; }

int tolower(int c) {
  if (isupper(c))
    return c | 32;
  return c;
}

int toupper(int c) {
  if (islower(c))
    return c & 0x5f;
  return c;
}

#define X(x) (((x) / 256 | (x)*256) % 65536)

const unsigned short **__ctype_b_loc(void) {
  static const unsigned short table[] = {
      0,        0,        0,        0,        0,        0,        0,
      0,        0,        0,        0,        0,        0,        0,
      0,        0,        0,        0,        0,        0,        0,
      0,        0,        0,        0,        0,        0,        0,
      0,        0,        0,        0,        0,        0,        0,
      0,        0,        0,        0,        0,        0,        0,
      0,        0,        0,        0,        0,        0,        0,
      0,        0,        0,        0,        0,        0,        0,
      0,        0,        0,        0,        0,        0,        0,
      0,        0,        0,        0,        0,        0,        0,
      0,        0,        0,        0,        0,        0,        0,
      0,        0,        0,        0,        0,        0,        0,
      0,        0,        0,        0,        0,        0,        0,
      0,        0,        0,        0,        0,        0,        0,
      0,        0,        0,        0,        0,        0,        0,
      0,        0,        0,        0,        0,        0,        0,
      0,        0,        0,        0,        0,        0,        0,
      0,        0,        0,        0,        0,        0,        0,
      0,        0,        X(0x200), X(0x200), X(0x200), X(0x200), X(0x200),
      X(0x200), X(0x200), X(0x200), X(0x200), X(0x320), X(0x220), X(0x220),
      X(0x220), X(0x220), X(0x200), X(0x200), X(0x200), X(0x200), X(0x200),
      X(0x200), X(0x200), X(0x200), X(0x200), X(0x200), X(0x200), X(0x200),
      X(0x200), X(0x200), X(0x200), X(0x200), X(0x200), X(0x200), X(0x160),
      X(0x4c0), X(0x4c0), X(0x4c0), X(0x4c0), X(0x4c0), X(0x4c0), X(0x4c0),
      X(0x4c0), X(0x4c0), X(0x4c0), X(0x4c0), X(0x4c0), X(0x4c0), X(0x4c0),
      X(0x4c0), X(0x8d8), X(0x8d8), X(0x8d8), X(0x8d8), X(0x8d8), X(0x8d8),
      X(0x8d8), X(0x8d8), X(0x8d8), X(0x8d8), X(0x4c0), X(0x4c0), X(0x4c0),
      X(0x4c0), X(0x4c0), X(0x4c0), X(0x4c0), X(0x8d5), X(0x8d5), X(0x8d5),
      X(0x8d5), X(0x8d5), X(0x8d5), X(0x8c5), X(0x8c5), X(0x8c5), X(0x8c5),
      X(0x8c5), X(0x8c5), X(0x8c5), X(0x8c5), X(0x8c5), X(0x8c5), X(0x8c5),
      X(0x8c5), X(0x8c5), X(0x8c5), X(0x8c5), X(0x8c5), X(0x8c5), X(0x8c5),
      X(0x8c5), X(0x8c5), X(0x4c0), X(0x4c0), X(0x4c0), X(0x4c0), X(0x4c0),
      X(0x4c0), X(0x8d6), X(0x8d6), X(0x8d6), X(0x8d6), X(0x8d6), X(0x8d6),
      X(0x8c6), X(0x8c6), X(0x8c6), X(0x8c6), X(0x8c6), X(0x8c6), X(0x8c6),
      X(0x8c6), X(0x8c6), X(0x8c6), X(0x8c6), X(0x8c6), X(0x8c6), X(0x8c6),
      X(0x8c6), X(0x8c6), X(0x8c6), X(0x8c6), X(0x8c6), X(0x8c6), X(0x4c0),
      X(0x4c0), X(0x4c0), X(0x4c0), X(0x200), 0,        0,        0,
      0,        0,        0,        0,        0,        0,        0,
      0,        0,        0,        0,        0,        0,        0,
      0,        0,        0,        0,        0,        0,        0,
      0,        0,        0,        0,        0,        0,        0,
      0,        0,        0,        0,        0,        0,        0,
      0,        0,        0,        0,        0,        0,        0,
      0,        0,        0,        0,        0,        0,        0,
      0,        0,        0,        0,        0,        0,        0,
      0,        0,        0,        0,        0,        0,        0,
      0,        0,        0,        0,        0,        0,        0,
      0,        0,        0,        0,        0,        0,        0,
      0,        0,        0,        0,        0,        0,        0,
      0,        0,        0,        0,        0,        0,        0,
      0,        0,        0,        0,        0,        0,        0,
      0,        0,        0,        0,        0,        0,        0,
      0,        0,        0,        0,        0,        0,        0,
      0,        0,        0,        0,        0,        0,        0,
      0,        0,        0,        0,        0,        0,
  };

  static const unsigned short *const ptable = table + 128;
  return (void *)&ptable;
}

const int32_t **__ctype_toupper_loc(void) {
  static const int32_t table[] = {
      0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
      0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
      0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
      0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
      0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
      0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
      0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
      0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
      0,   0,   0,   0,   0,   0,   0,   0,   0,   1,   2,   3,   4,   5,   6,
      7,   8,   9,   10,  11,  12,  13,  14,  15,  16,  17,  18,  19,  20,  21,
      22,  23,  24,  25,  26,  27,  28,  29,  30,  31,  32,  33,  34,  35,  36,
      37,  38,  39,  40,  41,  42,  43,  44,  45,  46,  47,  48,  49,  50,  51,
      52,  53,  54,  55,  56,  57,  58,  59,  60,  61,  62,  63,  64,  'A', 'B',
      'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',
      'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 91,  92,  93,  94,  95,  96,
      'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O',
      'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 123, 124, 125, 126,
      127, 0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
      0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
      0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
      0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
      0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
      0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
      0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
      0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
      0,   0,   0,   0,   0,   0,   0,   0,   0,
  };

  static const int32_t *const ptable = table + 128;

  return (void *)&ptable;
}

const int32_t **__ctype_tolower_loc(void) {
  static const int32_t table[] = {
      0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
      0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
      0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
      0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
      0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
      0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
      0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
      0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
      0,   0,   0,   0,   0,   0,   0,   0,   0,   1,   2,   3,   4,   5,   6,
      7,   8,   9,   10,  11,  12,  13,  14,  15,  16,  17,  18,  19,  20,  21,
      22,  23,  24,  25,  26,  27,  28,  29,  30,  31,  32,  33,  34,  35,  36,
      37,  38,  39,  40,  41,  42,  43,  44,  45,  46,  47,  48,  49,  50,  51,
      52,  53,  54,  55,  56,  57,  58,  59,  60,  61,  62,  63,  64,  'a', 'b',
      'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q',
      'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 91,  92,  93,  94,  95,  96,
      'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o',
      'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 123, 124, 125, 126,
      127, 0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
      0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
      0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
      0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
      0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
      0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
      0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
      0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
      0,   0,   0,   0,   0,   0,   0,   0,   0,
  };

  static const int32_t *const ptable = table + 128;

  return (void *)&ptable;
}

char *getenv(const char *name) { return 0; }

int isspace(int c) { return c == ' ' || (unsigned)c - '\t' < 5; }

// Copied from dietlibc
float strtof(const char *s, char **endptr) {
  register const char *p = s;
  register float value = 0.;
  int sign = +1;
  float factor;
  unsigned int expo;

  while (isspace(*p))
    p++;

  switch (*p) {
  case '-':
    sign = -1; /* fall through */
  case '+':
    p++;
  default:
    break;
  }

  while ((unsigned int)(*p - '0') < 10u)
    value = value * 10 + (*p++ - '0');

  if (*p == '.') {
    factor = 1.;

    p++;
    while ((unsigned int)(*p - '0') < 10u) {
      factor *= 0.1;
      value += (*p++ - '0') * factor;
    }
  }

  if ((*p | 32) == 'e') {
    expo = 0;
    factor = 10.L;

    switch (*++p) { // ja hier weiß ich nicht, was mindestens nach einem 'E'
                    // folgenden MUSS.
    case '-':
      factor = 0.1; /* fall through */
    case '+':
      p++;
      break;
    case '0':
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9':
      break;
    default:
      value = 0.L;
      p = s;
      goto done;
    }

    while ((unsigned int)(*p - '0') < 10u)
      expo = 10 * expo + (*p++ - '0');

    while (1) {
      if (expo & 1)
        value *= factor;
      if ((expo >>= 1) == 0)
        break;
      factor *= factor;
    }
  }

done:
  if (endptr != NULL)
    *endptr = (char *)p;

  return value * sign;
}

// Convert char to an int in base `base`,
// `base` must be 10 or 16, return -1 on error.
int char2int(char ch, unsigned int base)
{
    if (ch >= '0' && ch <= '9')
        return ch - '0';
    if (base == 16) {
        if (ch >= 'A' && ch <= 'F')
            return ch - 'A' + 10;
        if (ch >= 'a' && ch <= 'f')
            return ch - 'a' + 10;
    }
    return -1;
}

#define ldbltype long double
double strtod(const char *s, char **endptr) {
  register const char *p = s;
  register ldbltype value = 0.;
  int sign = +1;
  unsigned int base = 10;
  ldbltype base_inverse = (ldbltype)1/(ldbltype)base;
  ldbltype factor;
  unsigned int expo;
  unsigned int has_digits = 0;

  while (isspace(*p))
    p++;

  switch (*p) {
  case '-':
    sign = -1; /* fall through */
  case '+':
    p++;
  case '0':
    p++;
    if ((*p | 32) == 'x') {
      base = 16;
      base_inverse = (ldbltype)1/(ldbltype)base;
      p++;
    } else {
      p--;
    }
  default:
    break;
  }

  unsigned int current_value;
  while ((current_value = char2int(*p, base)) != -1) {
    p++;
    value = value * base + current_value;
    has_digits = 1;
  }

  if (*p == '.') {
    factor = 1.;

    p++;
    while ((current_value = char2int(*p, base)) != -1) {
      p++;
      factor *= base_inverse;
      value += current_value * factor;
      has_digits = 1;
    }
  }

  if ((*p | 32) == 'e' && base == 10) {
    expo = 0;
    factor = 10.;

    switch (*++p) { // ja hier weiß ich nicht, was mindestens nach einem 'E'
                    // folgenden MUSS.
    case '-':
      factor = 0.1; /* fall through */
    case '+':
      p++;
      break;
    case '0':
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9':
      break;
    default:
      value = 0.;
      p = s;
      goto done;
    }

    while ((unsigned int)(*p - '0') < 10u)
      expo = 10 * expo + (*p++ - '0');

    while (1) {
      if (expo & 1)
        value *= factor;
      if ((expo >>= 1) == 0)
        break;
      factor *= factor;
    }
  }

  if ((*p | 32) == 'p' && base == 16) {
    // TODO: add specifier p support
    // https://cplusplus.com/reference/cstdlib/strtod/
    //  - A 0x or 0X prefix, then a sequence of hexadecimal digits (as in isxdigit) optionally containing a period which separates the whole and fractional number parts. Optionally followed by a power of 2 exponent (a p or P character followed by an optional sign and a sequence of hexadecimal digits).
  }
done:
  if (endptr != NULL) {
    if (has_digits) {
      *endptr = (char *)p;
    } else {
      *endptr = (char *)s;
    }
  }

  return value * sign;
}

long double strtold(const char *s, char **endptr) {
  register const char *p = s;
  register long double value = 0.L;
  int sign = +1;
  long double factor;
  unsigned int expo;

  while (isspace(*p))
    p++;

  switch (*p) {
  case '-':
    sign = -1; /* fall through */
  case '+':
    p++;
  default:
    break;
  }

  while ((unsigned int)(*p - '0') < 10u)
    value = value * 10 + (*p++ - '0');

  if (*p == '.') {
    factor = 1.;

    p++;
    while ((unsigned int)(*p - '0') < 10u) {
      factor *= 0.1;
      value += (*p++ - '0') * factor;
    }
  }

  if ((*p | 32) == 'e') {
    expo = 0;
    factor = 10.L;

    switch (*++p) { // ja hier weiß ich nicht, was mindestens nach einem 'E'
                    // folgenden MUSS.
    case '-':
      factor = 0.1; /* fall through */
    case '+':
      p++;
      break;
    case '0':
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9':
      break;
    default:
      value = 0.L;
      p = s;
      goto done;
    }

    while ((unsigned int)(*p - '0') < 10u)
      expo = 10 * expo + (*p++ - '0');

    while (1) {
      if (expo & 1)
        value *= factor;
      if ((expo >>= 1) == 0)
        break;
      factor *= factor;
    }
  }

done:
  if (endptr != NULL)
    *endptr = (char *)p;

  return value * sign;
}
#endif // __CKB_IMPL_INCLUDED__
